{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "24f9968f_e15c2662",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-01-27T00:57:57Z",
      "side": 1,
      "message": "The vpmulhuw method used here has the potential to allow I420ToJ420 where the scaling value is greater than 1.0\n\nunpack or unzip can move the input bytes into the high byte or replicate them in both high and low bytes for increased precission.  \nmultiply by an 8.8 fixed point scale producing 8.16 fixed point, with an instruction that returns the upper 16 bits.\nThe resulting 16 bit value is signed int16.  Then add (subtract) the bias which would be -16 for converting I420ToJ420.\nPack the int16 to uint8 with saturation.\n\nOn both Intel and ARM, performance is similar to I420ToI420... the math is simple enough that memory (cache) is the limiting factor.",
      "revId": "e16dc91a51001493ea18ee255dae9ec438240fc7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}