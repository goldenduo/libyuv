{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d0cab238_4a794283",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-01-28T20:41:07Z",
      "side": 1,
      "message": "ARGBToJ444 first draft using C for UV.\nThe ARGBToUVJ444Row_NEON etc could be easily ported from ARGBToUV444Row_NEON using the JPeg (full range BT.601) coefficients\nBut it would be good to simplify ARGBToJ420\n\n1. implement subsampling as a first pass that averages 2 rows down using full accuracy (a+b+c+d+2)/4\nintel currently does this\n ((a+b+1)/2+(c+d+1)/2 + 1)/2\nand arm does this\n (a+b+c+d+1)/2\nand then uses rgb to uv coeffiecients that are 2x smaller.\nboth are low quality for performance, but arm especially has rounding error.\n\nthe subsampling quality needs to be improved.  its not necessary to do 2 passes to do it, but the performance cost is at most 20% on arm and 5% on intel.\nthe upside is \u0027exact\u0027 will use SIMD on intel and be 5x faster.\n2 pass is much simpler overall.\nthe improved quality would likely cause \u0027golden\u0027 test failures and might have to be optional, but projects already expect differences, so i think its managable.\n\n2. the argbtoyuv supports several variations - 7 bit vs 8 bit, truncation vs rounding.  7 bit is to maintain visual c and could be dropped, since the assembly is only for 32 bit x86.  But I did just set up a windows machine with vs2022, so if native visual c is still important, i may try setting up ninja\nrounding is done with a hardcoded add 0x80 that is 8 bit yuv specific.  this is bad because the coefficients cant be used for 10 bit yuv.  a rounding shift could be used, but i think the corect answer is truncation.  when upsampling 8 to 16, replicate.  when downsampling 16 to 8, truncate.\nIn this case, its the intel code that rounds and arm that truncates.  Its easy to remove the rounding on intel, and might lead to optimizations on arm to use mulh and/or uzip2\n\n3. the argbtouv could be split into argbtou and argbtov.  since the source is in cache, doing 2 passes is often faster due to single stream of writes at a time.\nas is there is some subsampling computation saving to having them combined, but that goes away with subsampling done once.\n\nthe math for uv doesnt easily lend itself to a single function with coefficients, due to signed math.\nBut it might still be possible to use an 8 bit dot product\nneg rgb channels that need to be subtracted\nsudot / vnni\n\nif kept as argbuv it can be called with channel swapped rgb vs bgr coefficients and swapped u and v pointers to achieve 2 endians - rgbtouv and bgrtouv",
      "revId": "284462ceb4c29cf4bc543991947b84318d430358",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05c81c65_01caedb3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1001562
      },
      "writtenOn": "2025-01-29T21:11:44Z",
      "side": 1,
      "message": "Please rebase the CL to resolve the merge conflict.",
      "revId": "284462ceb4c29cf4bc543991947b84318d430358",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b04d8241_9b066954",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-01-29T21:52:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "05c81c65_01caedb3",
      "revId": "284462ceb4c29cf4bc543991947b84318d430358",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9bc0ff0c_52e49444",
        "filename": "source/convert.cc",
        "patchSetId": 2
      },
      "lineNbr": 3551,
      "author": {
        "id": 1001562
      },
      "writtenOn": "2025-01-29T21:11:44Z",
      "side": 1,
      "message": "Can we coalesce rows in this function? Or would that make the temp row buffer too big?",
      "revId": "284462ceb4c29cf4bc543991947b84318d430358",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1d6cb412_e9a268ee",
        "filename": "source/convert.cc",
        "patchSetId": 2
      },
      "lineNbr": 3551,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-01-29T21:52:20Z",
      "side": 1,
      "message": "no.  coalesce only works for packed formats - one to one.\nhmmm... lemme think.  It doesnt work if the source does subsampling because the source isn\u0027t contiguous... it would step 2 rows.  But it might work on planar without subsampling.  So lets say it probably could.\nBut because these do a conversion, you dont necessarily want to coalesce.\nIf we end up with a very large width, the conversion / row buffer will miss the cache.\nThe way I\u0027ve handled that in the past is make a row function... e.g. RAWToUV444 and it internally does 2 steps - RAWToARGB + ARGBToUV444, taking a large width, but add an inner width loop that does a cache friendly size.\nThe main reason for doing this was RAWToUV444 is technically feasible and desirable on ARM, where you can LD3 the source.\nBut it has several drawbacks:\n1. the RAWToY and RAWToUV would redundently do the same conversion on Intel\n2. requires different row functions on ARM.  As is, this function leverages 2 existing row functions\n3. LD3 is slow, so even arm can optimize RAWToARGB using shuffles, but it requires unrolled code and registers for shufflers, that doesnt integrate into RGB to YUV functions nicely.\n4. The conversion here could be replaced with nearly any conversion.  If we get requests, I might make the type a parameter.\n\nThe issue you raise with row buffer to big is why we use malloc.  We used to use alloca, and prior to that, a simple char buf[MAXWIDTH].  even legit webcams were hitting the limits.  But for performance, it might make sense to break up the large widths.  e.g.  create a 2 KB buffer (on stack) and loop thru width 2k at a time.  Maybe this is something \u0027any\u0027 functions could do.\n\nMarking resolved because this is 2 pass, and even if we can coalesce, we dont want to.  I could add a comment about why, if you want.",
      "parentUuid": "9bc0ff0c_52e49444",
      "revId": "284462ceb4c29cf4bc543991947b84318d430358",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "696b430b_fdc0532f",
        "filename": "source/convert.cc",
        "patchSetId": 2
      },
      "lineNbr": 3551,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-01-29T22:20:10Z",
      "side": 1,
      "message": "added TODO comment\nThe simple solution is add a loop\nfor (x \u003d 0; x \u003c width; x +\u003d BLOCK_SIZE)\nand make row buffer BLOCK_SIZE with a relatively small value...eg 4096.\nexperimentation could tell us the best performance.  We need all the arrays to fit in L1 - the source, the row buffer, y, u and v.  So 5 arrays of BLOCK_SIZE.\nTotal size in this case would be\n4096 * 3 + 4096 * 4 + 4096 + 4096 + 4096 \u003d 10 * 4096 \u003d 40960.  High end cpus have 64k L1, but low end is 32k, so perhaps 2048 would work better, allow \u0027streaming\u0027 the source into cache.",
      "parentUuid": "1d6cb412_e9a268ee",
      "revId": "284462ceb4c29cf4bc543991947b84318d430358",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa84e2e9_e447d18b",
        "filename": "source/convert.cc",
        "patchSetId": 2
      },
      "lineNbr": 3717,
      "author": {
        "id": 1001562
      },
      "writtenOn": "2025-01-29T21:11:44Z",
      "side": 1,
      "message": "IMPORTANT: Free this buffer when done.",
      "revId": "284462ceb4c29cf4bc543991947b84318d430358",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d83555e8_9267c820",
        "filename": "source/convert.cc",
        "patchSetId": 2
      },
      "lineNbr": 3717,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-01-29T22:20:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fa84e2e9_e447d18b",
      "revId": "284462ceb4c29cf4bc543991947b84318d430358",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff820bbd_a870712b",
        "filename": "source/convert.cc",
        "patchSetId": 2
      },
      "lineNbr": 3724,
      "author": {
        "id": 1001562
      },
      "writtenOn": "2025-01-29T21:11:44Z",
      "side": 1,
      "message": "Nit: It looks nicer to operate on Y and then UV, unless the current order is better for some reason.",
      "revId": "284462ceb4c29cf4bc543991947b84318d430358",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "413aa7fd_4ccedb8d",
        "filename": "source/convert.cc",
        "patchSetId": 2
      },
      "lineNbr": 3724,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-01-29T21:52:20Z",
      "side": 1,
      "message": "This is for some reason :-)\nDoing UV first is faster.\nIn general, UV is more computational/less data than Y... Y is just memcpy speed.\nThe UV will leave the common source (row) in cache, speeding up Y.\nWhen its not subsampled, it probably makes less difference\nWhen the conversion puts the source in cache, its probably makes less difference\nBut I\u0027m pretty sure this is still the marginally faster order, since UV does 2 writes, making the source read less of a bottleneck than in the Y.\nPlus the Y is simplier - a very simple udot.  The UV is at best, a complicated dot product, but currently it is C, and sometimes it is Neon but not a dot product.",
      "parentUuid": "ff820bbd_a870712b",
      "revId": "284462ceb4c29cf4bc543991947b84318d430358",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "edc056eb_82bb3942",
        "filename": "source/convert_from_argb.cc",
        "patchSetId": 2
      },
      "lineNbr": 2552,
      "author": {
        "id": 1001562
      },
      "writtenOn": "2025-01-29T21:11:44Z",
      "side": 1,
      "message": "Nit: It looks nicer to operate on Y and then UV, unless the current order is better for some reason.",
      "revId": "284462ceb4c29cf4bc543991947b84318d430358",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "163b3ad1_d73cd824",
        "filename": "source/convert_from_argb.cc",
        "patchSetId": 2
      },
      "lineNbr": 2552,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-01-29T21:52:20Z",
      "side": 1,
      "message": "ditto.  UV first is for performance",
      "parentUuid": "edc056eb_82bb3942",
      "revId": "284462ceb4c29cf4bc543991947b84318d430358",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}