{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "471403fe_919e5e40",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-06-12T09:07:54Z",
      "side": 1,
      "message": "the dot product looks great.  the averaging of 4 pixels is frustratingly more than half the code.  I\u0027m struggling with the x86 version too.\n\nNote I suspect the unittests on check U, not V.\nThe UV plane in the unittest allocates row planar uv for efficiency.\nthe uv plane is half width.  we allocate enough per row for all the u followed by all the v.  the stride will be 2 * halfwidth.\nbut the test for equality only checked half width",
      "revId": "bf8f44b47d00bb5ea0b175d60e97e6196d65d233",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "de5e6e5e_bcfcfc35",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-06-12T09:11:57Z",
      "side": 1,
      "message": "the tbl to fix addp makes me think theres a way to avoid it.\nmaybe ld2 of 32 bit values to split even and odd argb pixels into 2 vectors?\nthen addw to add 4 vectors? \nif you have no immediate ideas, we can land it... its a big improvement",
      "revId": "bf8f44b47d00bb5ea0b175d60e97e6196d65d233",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8c044a54_19acde44",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1571352
      },
      "writtenOn": "2025-06-12T09:36:59Z",
      "side": 1,
      "message": "LD2 is still technically a permute, so I think the current approach of delaying the permute until we have as few vectors to permute as possible (two vectors after the reduction versus eight loaded) is going to be the best we can do here.",
      "parentUuid": "de5e6e5e_bcfcfc35",
      "revId": "bf8f44b47d00bb5ea0b175d60e97e6196d65d233",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f414c602_a0631ae9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-06-12T09:42:13Z",
      "side": 1,
      "message": "wouldnt this benefit from sme?\nwould sme2 register groups handle unrolling more efficiently than literal unrolling?\n\nnote there are \u0027vertical\u0027 dot products in sme2.  i\u0027m not sure how those are useful, but if you have 2 rows, or use ld2 and end up with 4 vectors, they can add up 4 pixels.\n\na different approach to subsampling is convert 4 pixels to 4 uv and apply the averaging after, preferably for free by adjusting the coefficients, setting the dot product accumulator to 2 instead of 0, and zip to get the high byte instead of shift. Its similar to what neon used to do, but the results are different... hopefully higher quality.\nthe subsampling first keeps the code simplier.  You could scale the ARGB to half sie and then convert to I444 and get the same result.",
      "revId": "bf8f44b47d00bb5ea0b175d60e97e6196d65d233",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "14a59fd4_8c0e5022",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1571352
      },
      "writtenOn": "2025-06-12T10:40:34Z",
      "side": 1,
      "message": "Yep, at least a streaming-SVE implementation is on my TODO list. I\u0027m aware of the vertical dotprods, I\u0027ll have to take a look to see whether they are applicable here.\n\nThe SME2 multi-reg loads are good in theory but would necessitate us specializing the SVE2/SME2 implementations (the multi-reg loads are only present from SVE2.1). This can possibly be resolved with even more macros...",
      "parentUuid": "f414c602_a0631ae9",
      "revId": "bf8f44b47d00bb5ea0b175d60e97e6196d65d233",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2cc166d_257fa5b0",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 290,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-06-12T09:07:54Z",
      "side": 1,
      "message": "overall this averaging is complicated and i wonder if theres a simplier way?\non intel i have a cl that uses zip to weave 2 pixels...\ne.g ARGBARGB -\u003e AARRGGBB, still as bytes, so that I can do paired adds with lengthen.\non neon i find addlp for first row and adalp for second row eliminates the \u0027add\u0027, since adalp does \u0027accumulate\u0027.  does sve2 have that?",
      "range": {
        "startLine": 290,
        "startChar": 72,
        "endLine": 290,
        "endChar": 76
      },
      "fixSuggestions": [
        {
          "fixId": "a1ffdfb1_c17f8a23",
          "description": "prompt_to_edit API",
          "replacements": [
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 280,
                "startChar": 0,
                "endLine": 288,
                "endChar": 0
              },
              "replacement": "  \"uaddw    z16.h, z0.b, z4.b                     \\n\" /* ABCD(br) */        \\\n  \"uaddw    z17.h, z1.b, z5.b                     \\n\" /* EFGH(br) */        \\\n  \"uaddw    z18.h, z2.b, z6.b                     \\n\" /* IJKL(br) */        \\\n  \"uaddw    z19.h, z3.b, z7.b                     \\n\" /* MNOP(br) */        \\\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 289,
                "startChar": 0,
                "endLine": 294,
                "endChar": 0
              },
              "replacement": "  \"rshrnb    z0.b, z16.h, #2                      \\n\" /* ABEFCDGH(b0) */  \\\n  \"rshrnb    z1.b, z17.h, #2                      \\n\" /* ABEFCDGH(r0) */  \\\n  \"rshrnb    z2.b, z18.h, #2                      \\n\" /* IJMNKLOP(b0) */  \\\n  \"rshrnb    z3.b, z19.h, #2                      \\n\" /* IJMNKLOP(r0) */  \\\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 295,
                "startChar": 0,
                "endLine": 299,
                "endChar": 0
              },
              "replacement": "  \"zip1      z0.s, z0.b, z1.b                     \\n\" /* ABEFCDGH(bgra) */  \\\n  \"zip1      z1.s, z2.b, z3.b                     \\n\" /* IJMNKLOP(bgra) */  \\\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 311,
                "startChar": 0,
                "endLine": 311,
                "endChar": 0
              },
              "replacement": "  \"usdot     z20.s, z0.b, z25.b                   \\n\"                       \\\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 312,
                "startChar": 0,
                "endLine": 313,
                "endChar": 0
              },
              "replacement": ""
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 319,
                "startChar": 0,
                "endLine": 319,
                "endChar": 0
              },
              "replacement": "  \"zip1     z16.h, z16.b, z17.b                   \\n\"                       \\\n  \"zip1     z20.h, z20.b, z21.b                   \\n\"                       \\\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 320,
                "startChar": 0,
                "endLine": 325,
                "endChar": 0
              },
              "replacement": "  \"st1b     {z16.b}, p5, [%[dst_u]]               \\n\" /* U */               \\\n  \"st1b     {z20.b}, p5, [%[dst_v]]               \\n\" /* V */               \\\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 347,
                "startChar": 0,
                "endLine": 348,
                "endChar": 0
              },
              "replacement": "      // Generate some TBL indices to undo the interleaving from ZIP1.\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 359,
                "startChar": 0,
                "endLine": 360,
                "endChar": 0
              },
              "replacement": "      \"ptrue  p5.b                                   \\n\"\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 373,
                "startChar": 0,
                "endLine": 374,
                "endChar": 0
              },
              "replacement": "      \"whilelt  p5.b, wzr, %w[width]                 \\n\"  //\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 570,
                "startChar": 0,
                "endLine": 571,
                "endChar": 0
              },
              "replacement": "      \"cntb    %x[vl]                                  \\n\"\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 589,
                "startChar": 0,
                "endLine": 591,
                "endChar": 0
              },
              "replacement": "      \"whilelt p1.b, wzr, %w[width]                    \\n\"\n      \"whilelt p2.b, %w[vl], %w[width]                 \\n\"\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 638,
                "startChar": 0,
                "endLine": 639,
                "endChar": 0
              },
              "replacement": "      \"cnth    %x[vl]                            \\n\"\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 677,
                "startChar": 0,
                "endLine": 678,
                "endChar": 0
              },
              "replacement": "      \"cnth    %x[vl]                            \\n\"\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 832,
                "startChar": 0,
                "endLine": 832,
                "endChar": 0
              },
              "replacement": "  uint32_t rem;\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 855,
                "startChar": 0,
                "endLine": 855,
                "endChar": 0
              },
              "replacement": "      \"add     %w[rem], %w[width], %w[width], lsl #1     \\n\"\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 864,
                "startChar": 0,
                "endLine": 865,
                "endChar": 0
              },
              "replacement": "        [vl] \"\u003d\u0026r\"(vl),                      // %[vl]\n        [rem] \"\u003d\u0026r\"(rem)                      // %[rem]\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 878,
                "startChar": 0,
                "endLine": 879,
                "endChar": 0
              },
              "replacement": "      \"ptrue   p1.b, mul3                                \\n\"\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 904,
                "startChar": 0,
                "endLine": 905,
                "endChar": 0
              },
              "replacement": "      \"add     %w[rem_mul3], %w[width], %w[width], lsl #1  \\n\"\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 999,
                "startChar": 0,
                "endLine": 1000,
                "endChar": 0
              },
              "replacement": "      // the tail. We use p1 to load the second half of the vector.\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 1066,
                "startChar": 0,
                "endLine": 1066,
                "endChar": 0
              },
              "replacement": "      // We use p1, p2, p3 to load the remaining elements.\n"
            },
            {
              "path": "source/row_sve.cc",
              "range": {
                "startLine": 1121,
                "startChar": 0,
                "endLine": 1121,
                "endChar": 0
              },
              "replacement": "      // We use p1 to load the second half of the vector.\n"
            }
          ]
        }
      ],
      "revId": "bf8f44b47d00bb5ea0b175d60e97e6196d65d233",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5f4f44dd_09fee62a",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 290,
      "author": {
        "id": 1571352
      },
      "writtenOn": "2025-06-12T09:26:28Z",
      "side": 1,
      "message": "UADALP does exist in SVE2, that was one of my ideas as well, but it is slow on Cortex-A510 and requires permuting (or LD3/LD4) for all eight of the loaded input vectors (as opposed to only needing to permute two vectors of the results after averaging).",
      "parentUuid": "e2cc166d_257fa5b0",
      "range": {
        "startLine": 290,
        "startChar": 72,
        "endLine": 290,
        "endChar": 76
      },
      "revId": "bf8f44b47d00bb5ea0b175d60e97e6196d65d233",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7f46ae3a_a9cb6990",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 290,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-06-12T09:54:56Z",
      "side": 1,
      "message": "I dont quite follow why addp on 32 bit values.  the previous addl converted argb bytes to argb shorts, but still b,g,r,a?  so you have 64 bit pixels... seems like the addp should be .d (double)?\nbut i assume you tested this.\nfor sve I can run tests on samsung s23/s24 for performance.\nfor sme we can run unittests on chromium\u0027s emulator, but it doesnt provide speed analysis.  I think we\u0027re still waiting for something with x930 for sme benchmarking.",
      "parentUuid": "5f4f44dd_09fee62a",
      "range": {
        "startLine": 290,
        "startChar": 72,
        "endLine": 290,
        "endChar": 76
      },
      "revId": "bf8f44b47d00bb5ea0b175d60e97e6196d65d233",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "40acad78_fc419675",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 290,
      "author": {
        "id": 1571352
      },
      "writtenOn": "2025-06-12T10:40:34Z",
      "side": 1,
      "message": "The UADDL[BT] produces widened pairs of 16-bit (only 9-bits non-zero) elements: either br or ga. The 32-bit ADDP then adds adjacent components. We regain the fully four-interleaved components by the RSHRN[BT] interleaving narrowing instructions later.\n\nIf we had used a widening load instruction to widen from 8-\u003e16-bits as part of the load then we would be able to add without de-interleaving and could use a 64-bit element ADDP as you suggest. This works okay for that bit, but then we would be interleaving unrelated elements with the later RSHRN[BT] so we would still need the permutes to undo this later. Additionally, using widening loads means we would need double the number of instructions which isn\u0027t ideal either.",
      "parentUuid": "7f46ae3a_a9cb6990",
      "range": {
        "startLine": 290,
        "startChar": 72,
        "endLine": 290,
        "endChar": 76
      },
      "revId": "bf8f44b47d00bb5ea0b175d60e97e6196d65d233",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}