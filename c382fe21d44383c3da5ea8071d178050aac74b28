{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e5ab6237_46f880e2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-07-20T06:04:16Z",
      "side": 1,
      "message": "cpuid looks good.  Needs a second reviewer",
      "revId": "c382fe21d44383c3da5ea8071d178050aac74b28",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cde50b24_295fc7fb",
        "filename": "source/cpu_id.cc",
        "patchSetId": 3
      },
      "lineNbr": 362,
      "author": {
        "id": 1001562
      },
      "writtenOn": "2025-07-20T15:24:14Z",
      "side": 1,
      "message": "[This question is unrelated to this CL.]\n\nFrank: Do these *MipsCpuCaps() functions need to be declared with `LIBYUV_API`? I think `LIBYUV_API` exports the functions from the shared libraries / DLLs.",
      "range": {
        "startLine": 362,
        "startChar": 0,
        "endLine": 362,
        "endChar": 10
      },
      "revId": "c382fe21d44383c3da5ea8071d178050aac74b28",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f707c5f_a9841f82",
        "filename": "source/cpu_id.cc",
        "patchSetId": 3
      },
      "lineNbr": 408,
      "author": {
        "id": 1001562
      },
      "writtenOn": "2025-07-20T15:24:14Z",
      "side": 1,
      "message": "Should we keep the original cpucfg code for non-Linux platforms like the folllowing?\n\n```\n#if defined(__loongarch__)\n#if defined(__linux__)\n// Define hwcap values ourselves: building with an old auxv header where these\n// hwcap values are not defined should not prevent features from being enabled.\n#define YUV_LOONGARCH_HWCAP_LSX (1 \u003c\u003c 4)\n#define YUV_LOONGARCH_HWCAP_LASX (1 \u003c\u003c 5)\n\nLIBYUV_API SAFEBUFFERS int LoongarchCpuCaps(void) {\n  int flag \u003d 0;\n  unsigned long hwcap \u003d getauxval(AT_HWCAP);\n\n  if (hwcap \u0026 YUV_LOONGARCH_HWCAP_LSX)\n    flag |\u003d kCpuHasLSX;\n\n  if (hwcap \u0026 YUV_LOONGARCH_HWCAP_LASX)\n    flag |\u003d kCpuHasLASX;\n  return flag;\n}\n#else  // !defined(__linux__)\n#define LOONGARCH_CFG2 0x2\n#define LOONGARCH_CFG2_LSX (1 \u003c\u003c 6)\n#define LOONGARCH_CFG2_LASX (1 \u003c\u003c 7)\n\nLIBYUV_API SAFEBUFFERS int LoongarchCpuCaps(void) {\n  int flag \u003d 0;\n  uint32_t cfg2 \u003d 0;\n\n  __asm__ volatile(\"cpucfg %0, %1 \\n\\t\" : \"+\u0026r\"(cfg2) : \"r\"(LOONGARCH_CFG2));\n\n  if (cfg2 \u0026 LOONGARCH_CFG2_LSX)\n    flag |\u003d kCpuHasLSX;\n\n  if (cfg2 \u0026 LOONGARCH_CFG2_LASX)\n    flag |\u003d kCpuHasLASX;\n  return flag;\n}\n#endif. // defined(__linux__)\n#endif. // defined(__loongarch__)\n```",
      "revId": "c382fe21d44383c3da5ea8071d178050aac74b28",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ec43a631_5c65b2ce",
        "filename": "source/cpu_id.cc",
        "patchSetId": 3
      },
      "lineNbr": 408,
      "author": {
        "id": 4233841
      },
      "writtenOn": "2025-07-20T16:21:38Z",
      "side": 1,
      "message": "I prefer to be conservative here, i.e. if someone is going to add a new OS for LoongArch (s)he should add the implementation for the OS, instead of shipping a \"generic\" solution which may cause SIGILL on some OS we don\u0027t really understand.\n\nAlso we already have\n\n```\n#if defined(__loongarch__) \u0026\u0026 defined(__linux__)\n  cpu_info \u003d LoongarchCpuCaps();\n  cpu_info |\u003d kCpuHasLOONGARCH;\n#endif\n```\n\nso this function is unused (yet) on a non-Linux OS, even if one exists.",
      "parentUuid": "1f707c5f_a9841f82",
      "revId": "c382fe21d44383c3da5ea8071d178050aac74b28",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47bb72fc_d6e13ae4",
        "filename": "source/cpu_id.cc",
        "patchSetId": 3
      },
      "lineNbr": 408,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-07-20T18:18:38Z",
      "side": 1,
      "message": "The cpucfg instruction should work identically on linux, indicating lsx or lasx isa are available?\nhwcap wont work, even on linux, if\n1. it is not implemented/complete... which has been an issue for arm\n2. within chrome sandbox.  the simd instructions work, but hwcaps can not be called.\n3. different OS like unix (apple), windows, or embedded systems\n4. within emulators\n\nas long as the instruction is available in user mode?\n\nI\u0027m fine with landing hwcaps, if this is what loongson wants, but agree with wtc@ the cpucfg looks useful, at least for non-linux",
      "parentUuid": "ec43a631_5c65b2ce",
      "revId": "c382fe21d44383c3da5ea8071d178050aac74b28",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "342c48c5_d9fb5d34",
        "filename": "source/cpu_id.cc",
        "patchSetId": 3
      },
      "lineNbr": 408,
      "author": {
        "id": 1001562
      },
      "writtenOn": "2025-07-21T01:55:02Z",
      "side": 1,
      "message": "Ruoyao: You are right. I verified that `LoongarchCpuCaps()` is called only inside `#if defined(__loongarch__) \u0026\u0026 defined(__linux__)`. So it is correct to define `LoongarchCpuCaps()` inside  `#if defined(__loongarch__) \u0026\u0026 defined(__linux__)` here.",
      "parentUuid": "47bb72fc_d6e13ae4",
      "revId": "c382fe21d44383c3da5ea8071d178050aac74b28",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "89a93efc_574735b9",
        "filename": "source/cpu_id.cc",
        "patchSetId": 3
      },
      "lineNbr": 408,
      "author": {
        "id": 1001562
      },
      "writtenOn": "2025-07-21T01:56:48Z",
      "side": 1,
      "message": "Frank: Perhaps the Chrome sandbox should allow `getauxval(AT_HWCAP)` to be called?",
      "parentUuid": "342c48c5_d9fb5d34",
      "revId": "c382fe21d44383c3da5ea8071d178050aac74b28",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d605e45_2a220b0d",
        "filename": "source/cpu_id.cc",
        "patchSetId": 3
      },
      "lineNbr": 408,
      "author": {
        "id": 4233841
      },
      "writtenOn": "2025-07-22T08:18:38Z",
      "side": 1,
      "message": "\u003e The cpucfg instruction should work identically on linux, indicating lsx or lasx isa are available?\n\nThe ISA is available but we\u0027ll still get SIGILL if the kernel does not support it.  See https://www.kernelconfig.io/CONFIG_CPU_HAS_LSX.\n\n\u003e hwcap wont work, even on linux, if\n\u003e 1. it is not implemented/complete... which has been an issue for arm\n\nIt\u0027s implemented on LoongArch since Linux starts to support LoongArch, i.e. Linux 5.19.\n\n\u003e 2. within chrome sandbox.  the simd instructions work, but hwcaps can not be called.\n\nIIUC the auxiliary vectors are loaded from kernel into the process once a process starts, and getauxval() does not actually invoke a syscall so it won\u0027t be blocked by the sandbox.  And aarch64-linux already uses getauxval(AT_HWCAP) anyway.\n\n\u003e 3. different OS like unix (apple), windows, or embedded systems\n\nLoongArch does not have a different OS at least now.\n\n\u003e 4. within emulators\n\nI\u0027d say the emulator is buggy if it tries to emulate Linux but fail to implement HWCAP.\n\n\u003e \n\u003e as long as the instruction is available in user mode?\n\nThe ISA needs kernel support even in user mode.\n\n\u003e \n\u003e I\u0027m fine with landing hwcaps, if this is what loongson wants, but agree with wtc@ the cpucfg looks useful, at least for non-linux",
      "parentUuid": "47bb72fc_d6e13ae4",
      "revId": "c382fe21d44383c3da5ea8071d178050aac74b28",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "61327617_fe5e63e8",
        "filename": "source/cpu_id.cc",
        "patchSetId": 3
      },
      "lineNbr": 408,
      "author": {
        "id": 4233841
      },
      "writtenOn": "2025-07-23T08:12:17Z",
      "side": 1,
      "message": "Wan-Ten: Per my knowledge getauxval() does not invoke any syscall.  We can demonstrate it with a simple test program:\n\n```\n#include \u003csys/prctl.h\u003e\n#include \u003cseccomp.h\u003e\n#include \u003csys/auxv.h\u003e\n#include \u003csys/syscall.h\u003e\n#include \u003cunistd.h\u003e\nint main()\n{\n\tprctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);\n\t_Bool x \u003d getauxval(AT_HWCAP) \u0026 HWCAP_LOONGARCH_LASX;\n        // The normal exit routine invokes syscall and fail with SECCOMP_MODE_STRICT\n\tsyscall(SYS_exit, !x);\n}\n```\n\nThe program successfully runs.\n\nWhen the program starts the kernel fills the \"auxiliary vector\" into the program memory, so getauxval() is just a simple memory load.",
      "parentUuid": "6d605e45_2a220b0d",
      "revId": "c382fe21d44383c3da5ea8071d178050aac74b28",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8d731968_96befa29",
        "filename": "source/cpu_id.cc",
        "patchSetId": 3
      },
      "lineNbr": 470,
      "author": {
        "id": 1001562
      },
      "writtenOn": "2025-07-21T01:55:02Z",
      "side": 1,
      "message": "`LoongarchCpuCaps()` is only called here, inside `#if defined(__loongarch__) \u0026\u0026 defined(__linux__)`.",
      "revId": "c382fe21d44383c3da5ea8071d178050aac74b28",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}