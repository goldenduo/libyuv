{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "49df28b1_5b101027",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1571352
      },
      "writtenOn": "2024-12-03T20:43:36Z",
      "side": 1,
      "message": "(this is based on a suggestion from here: https://chromium-review.googlesource.com/c/libyuv/libyuv/+/6025828/1/source/row_sve.cc#99 )",
      "revId": "a32a5335a549a0b59bb095fc75f4065f44455c44",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8eff608d_d5aaae50",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-12-03T21:50:17Z",
      "side": 1,
      "message": "Looks right, thanks.\nOn most cpus with 2 vector units it makes sense to try to issue 2 instructions per cycle that can co-issue as well as allow for some latency (4 cycles) before using the result.\nOn cpus with 4 vector units that means unrolling a bit more and sometimes using additional (destination) registers to allow for the co-issueing.\nFor every 2 vector instructions, there can also be loads and GPR instructions.\nIts really microops, not instructions, that mainly determine scheduling, so keeping to simplier instructions helps.",
      "revId": "a32a5335a549a0b59bb095fc75f4065f44455c44",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}