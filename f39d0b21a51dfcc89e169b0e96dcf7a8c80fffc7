{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f9625f5d_b220ec9e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-10-27T20:45:51Z",
      "side": 1,
      "message": "f32mm detect for arm.  tested on android/chrome emulator",
      "revId": "f39d0b21a51dfcc89e169b0e96dcf7a8c80fffc7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b690f4b0_5b9f9cf5",
        "filename": "include/libyuv/cpu_id.h",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1001562
      },
      "writtenOn": "2025-10-27T21:12:51Z",
      "side": 1,
      "message": "I found that include/libyuv/cpu_id.h is a public header. For backward compatibility we should not change the values of the constants `kCpuHasSME` and `kCpuHasSME2`.\n\nAre `kCpuHasSME` and `kCpuHasSME2` part of libyuv\u0027s public API? Or are they actually internal constants and just exposed in a public header unintentionally?",
      "revId": "f39d0b21a51dfcc89e169b0e96dcf7a8c80fffc7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "111fabb9_770d575a",
        "filename": "include/libyuv/cpu_id.h",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-10-27T21:18:04Z",
      "side": 1,
      "message": "Done.  The names of the constants (kCpuHasSME) are public, but the user is expected to compile against the named constants, not bypass them.  We\u0027ve done renumbering in the past, several times.  \nBut in this case, its easy to avoid, so done",
      "parentUuid": "b690f4b0_5b9f9cf5",
      "revId": "f39d0b21a51dfcc89e169b0e96dcf7a8c80fffc7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cac9b512_d95b80ef",
        "filename": "include/libyuv/cpu_id.h",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1001562
      },
      "writtenOn": "2025-10-27T21:23:23Z",
      "side": 1,
      "message": "Thanks for the reply. This means libyuv doesn\u0027t provide binary compatibility. (Binary compatibility means an application that uses the libyuv shared library (.so) does not need to be recompiled when a new version of the libyuv shared library is installed.)",
      "parentUuid": "111fabb9_770d575a",
      "revId": "f39d0b21a51dfcc89e169b0e96dcf7a8c80fffc7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "30d002a7_e820eb80",
        "filename": "include/libyuv/cpu_id.h",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2025-10-27T21:29:56Z",
      "side": 1,
      "message": "It wasnt really on my radar, but I did notice hwcaps attempts to be binary compatible.  I dont know if we should make any promises, but lets try not to break binary compatibility.\n\nthe yuv to rgb \u0027matrix\u0027 structures would be the main binary format.  If a user defined one and the format changed, it would break.\n\ncpus come and go, so its mainly been about keeping tidy and less than 32 bits.  But tidiness can be deferred until a cleanup is necessary",
      "parentUuid": "cac9b512_d95b80ef",
      "revId": "f39d0b21a51dfcc89e169b0e96dcf7a8c80fffc7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}